


import React, { useState, useEffect, useRef, useCallback, Fragment, memo } from 'react';
import ReactDOM from 'react-dom/client';
import { GoogleGenAI, GenerateContentResponse } from '@google/genai';

// --- TYPE DEFINITIONS ---
interface MusicState {
    service: 'youtube' | 'spotify';
    isYoutubeLoggedIn: boolean;
    isSpotifyLoggedIn: boolean;
    youtubeInput: string;
    spotifyInput: string;
    currentYoutubeUrl: string;
    currentSpotifyUrl: string;
}
interface TimerData {
  id: number;
  label: string;
  initialDuration: number;
  duration: number;
  remaining: number;
  isRunning: boolean;
  startTime: number | null;
  musicState: MusicState | null;
}
interface Settings {
  theme: string;
  darkMode: boolean;
  alarmSound: string;
  iCalUrl: string;
}
interface IconProps { name: string; className?: string; }
interface ApiKeyGateProps { onSelectKey: () => void; onSaveKey: (key: string) => void; isAistudioAvailable: boolean; }
interface HeaderProps { onSettingsClick: () => void; onChatClick: () => void; hasApiKey: boolean; }
interface MusicPlayerCardProps { timer: TimerData; onDelete: (id: number) => void; onUpdate: (id: number, updates: Partial<TimerData>) => void; }
interface TimerProps { timer: TimerData; onDelete: (id: number) => void; onToggle: (id: number) => void; onReset: (id: number) => void; onUpdate: (id: number, updates: Partial<TimerData>) => void; alarmSoundUrl: string; compact?: boolean; }
interface TimerListProps { timers: TimerData[]; onAdd: () => void; onDelete: (id: number) => void; onToggle: (id: number) => void; onReset: (id: number) => void; onUpdate: (id: number, updates: Partial<TimerData>) => void; alarmSoundUrl: string; }
interface ModalProps { isOpen: boolean; onClose: () => void; title: string; children: React.ReactNode; }
interface AddTimerModalProps { isOpen: boolean; onClose: () => void; onAddTimer: (timer: { label: string; duration: number }) => void; }
interface SettingsModalProps { isOpen: boolean; onClose: () => void; settings: Settings; onSettingsChange: (settings: Settings) => void; }
interface ChatBotProps { isOpen: boolean; onClose: () => void; timers: TimerData[]; onDeleteTimer: (id: number) => void; onToggleTimer: (id: number) => void; onResetTimer: (id: number) => void; onUpdateTimer: (id: number, updates: Partial<TimerData>) => void; alarmSoundUrl: string; onApiKeyInvalid: () => void; apiKey: string | undefined; }
interface NavButtonProps { tabName: string; icon: string; children: React.ReactNode; activeTab: string; onTabClick: (tabName: string) => void; }
interface Message { role: 'user' | 'model'; text: string; }


// --- CONSTANTS ---
const themes = {
    default: { dark: { primary: '79 70 229', secondary: '16 185 129', background: '17 24 39', surface: '31 41 55', 'text-primary': '249 250 251', 'text-secondary': '156 163 175', }, light: { primary: '79 70 229', secondary: '16 185 129', background: '243 244 246', surface: '255 255 255', 'text-primary': '17 24 39', 'text-secondary': '55 65 81', } },
    ocean: { dark: { primary: '59 130 246', secondary: '52 211 153', background: '15 23 42', surface: '30 41 59', 'text-primary': '241 245 249', 'text-secondary': '148 163 184', }, light: { primary: '59 130 246', secondary: '22 163 74', background: '240 249 255', surface: '255 255 255', 'text-primary': '30 41 59', 'text-secondary': '71 85 105', } },
    sunset: { dark: { primary: '249 115 22', secondary: '239 68 68', background: '28 25 23', surface: '41 37 36', 'text-primary': '250 250 249', 'text-secondary': '168 162 158', }, light: { primary: '234 88 12', secondary: '220 38 38', background: '254 252 251', surface: '255 255 255', 'text-primary': '28 25 23', 'text-secondary': '68 64 60', } },
    forest: { dark: { primary: '34 197 94', secondary: '202 138 4', background: '20 30 20', surface: '30 46 30', 'text-primary': '220 252 231', 'text-secondary': '163 230 170', }, light: { primary: '22 163 74', secondary: '202 138 4', background: '240 253 244', surface: '255 255 255', 'text-primary': '21 21 21', 'text-secondary': '63 63 63', } },
    graphite: { dark: { primary: '148 163 184', secondary: '100 116 139', background: '15 23 42', surface: '30 41 59', 'text-primary': '241 245 249', 'text-secondary': '148 163 184', }, light: { primary: '71 85 105', secondary: '100 116 139', background: '241 245 249', surface: '255 255 255', 'text-primary': '15 23 42', 'text-secondary': '51 65 85', } },
    rose: { dark: { primary: '251 113 133', secondary: '251 146 60', background: '53 23 29', surface: '79 32 43', 'text-primary': '255 241 242', 'text-secondary': '253 164 175', }, light: { primary: '244 63 94', secondary: '217 119 6', background: '255 241 242', surface: '255 255 255', 'text-primary': '131 24 67', 'text-secondary': '190 24 93', } }
};
const ALARM_SOUNDS = {
    default: { name: 'Alarm Clock', url: 'https://cdn.jsdelivr.net/gh/k-g-p/alarm-sounds/sounds/alarm-clock.mp3' },
    digital: { name: 'Digital', url: 'https://cdn.jsdelivr.net/gh/k-g-p/alarm-sounds/sounds/digital.mp3' },
    bell: { name: 'School Bell', url: 'https://cdn.jsdelivr.net/gh/k-g-p/alarm-sounds/sounds/school-bell.mp3' },
    rooster: { name: 'Rooster', url: 'https://cdn.jsdelivr.net/gh/k-g-p/alarm-sounds/sounds/rooster.mp3' },
    beep: { name: 'Beep', url: 'https://cdn.jsdelivr.net/gh/k-g-p/alarm-sounds/sounds/beep.mp3' },
    buzzer: { name: 'Buzzer', url: 'https://cdn.jsdelivr.net/gh/k-g-p/alarm-sounds/sounds/buzzer.mp3' },
    electronic: { name: 'Electronic', url: 'https://cdn.jsdelivr.net/gh/k-g-p/alarm-sounds/sounds/electronic.mp3' },
    kitchen: { name: 'Kitchen Timer', url: 'https://cdn.jsdelivr.net/gh/k-g-p/alarm-sounds/sounds/kitchen-timer.mp3' },
};
const INITIAL_SETTINGS: Settings = { theme: 'default', darkMode: true, alarmSound: 'default', iCalUrl: '' };
const MUSIC_SOURCES = {
  youtube: 'https://www.youtube.com/embed/jfKfPfyJRdk?autoplay=1', // Lofi Girl
  spotify: 'https://open.spotify.com/embed/playlist/37i9dQZF1DXcBWIGoYBM5M' // Lofi Beats
};
const INITIAL_MUSIC_STATE: MusicState = {
    service: 'youtube',
    isYoutubeLoggedIn: false,
    isSpotifyLoggedIn: false,
    youtubeInput: '',
    spotifyInput: '',
    currentYoutubeUrl: MUSIC_SOURCES.youtube,
    currentSpotifyUrl: MUSIC_SOURCES.spotify
};

// --- ICONS ---
// FIX: Add props type to the Icon component to resolve TypeScript errors.
const Icon = memo(({ name, className }: IconProps) => {
  const icons = {
      clock: <path strokeLinecap="round" strokeLinejoin="round" d="M12 6v6h4.5m4.5 0a9 9 0 11-18 0 9 9 0 0118 0z" />,
      timer: <path strokeLinecap="round" strokeLinejoin="round" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z" />,
      plus: <path strokeLinecap="round" strokeLinejoin="round" d="M12 4.5v15m7.5-7.5h-15" />,
      cog: <path strokeLinecap="round" strokeLinejoin="round" d="M10.5 6h9.75M10.5 6a1.5 1.5 0 11-3 0m3 0a1.5 1.5 0 10-3 0M3.75 6H7.5m3 12h9.75m-9.75 0a1.5 1.5 0 01-3 0m3 0a1.5 1.5 0 00-3 0m-3.75 0H7.5m9-6h3.75m-3.75 0a1.5 1.5 0 01-3 0m3 0a1.5 1.5 0 00-3 0m-9.75 0h9.75" />,
      chat: <path strokeLinecap="round" strokeLinejoin="round" d="M8.625 12a.375.375 0 11-.75 0 .375.375 0 01.75 0zm0 0H8.25m4.125 0a.375.375 0 11-.75 0 .375.375 0 01.75 0zm0 0H12m3.375 0a.375.375 0 11-.75 0 .375.375 0 01.75 0z" />,
      x: <path strokeLinecap="round" strokeLinejoin="round" d="M6 18L18 6M6 6l12 12" />,
      play: <path d="M8 5.13v13.74a1 1 0 0 0 1.5.866l10.8-6.87a1 1 0 0 0 0-1.732L9.5 4.264A1 1 0 0 0 8 5.13z" />,
      pause: <path d="M5.5 5h3v14h-3V5zm10 0h3v14h-3V5z" />,
      trash: <path strokeLinecap="round" strokeLinejoin="round" d="M14.74 9l-.346 9m-4.788 0L9.26 9m9.968-3.21c.342.052.682.107 1.022.166m-1.022-.165L18.16 19.673a2.25 2.25 0 01-2.226 2.077H8.062a2.25 2.25 0 01-2.226-2.077L3.882 5.79m18.12-1.02A1.125 1.125 0 0020.25 5.25h-4.5M12 5.25V3m-4.5 2.25H3.75m0 0A1.125 1.125 0 012.625 4.125h18.75c.621 0 1.125.504 1.125 1.125v0" />,
      send: <path strokeLinecap="round" strokeLinejoin="round" d="M6 12L3.269 3.126A59.768 59.768 0 0121.485 12 59.77 59.77 0 013.27 20.876L5.999 12zm0 0h7.5" />,
      reset: <path strokeLinecap="round" strokeLinejoin="round" d="M16.023 9.348h4.992v-.001M2.985 19.644v-4.992m0 0h4.992m-4.993 0l3.181 3.183a8.25 8.25 0 0011.667 0l3.181-3.183m-4.991-2.691V5.25a8.25 8.25 0 00-11.667 0v1.118" />,
  };
  const svgProps = name === 'play' || name === 'pause' ? { fill: 'currentColor' } : { fill: 'none', strokeWidth: 1.5, stroke: 'currentColor' };
  return <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" {...svgProps} className={className}>{icons[name]}</svg>;
});

// --- UTILS ---
// FIX: The `data` parameter should be explicitly typed as a string.
const parseICal = (data: string) => {
    const events = [];
    const eventBlocks = data.match(/BEGIN:VEVENT([\s\S]*?)END:VEVENT/g);
    if (!eventBlocks) return [];
    // FIX: Add type annotation for the dateStr parameter.
    const parseDate = (dateStr: string | undefined) => {
        if (!dateStr) return null;
        const year = parseInt(dateStr.substring(0, 4), 10);
        const month = parseInt(dateStr.substring(4, 6), 10);
        const day = parseInt(dateStr.substring(6, 8), 10);
        const hour = parseInt(dateStr.substring(9, 11), 10);
        const minute = parseInt(dateStr.substring(11, 13), 10);
        const second = parseInt(dateStr.substring(13, 15), 10);
        const isUTC = dateStr.endsWith('Z');
        if (isUTC) return new Date(Date.UTC(year, month - 1, day, hour, minute, second));
        return new Date(year, month - 1, day, hour, minute, second);
    };
    eventBlocks.forEach(block => {
        const summaryMatch = block.match(/SUMMARY:(.*)/);
        const dtstartMatch = block.match(/DTSTART(?:;.*)?:(.*)/);
        if (summaryMatch && dtstartMatch) {
            const startDate = parseDate(dtstartMatch[1]?.trim());
            if (startDate && startDate > new Date()) {
                events.push({ summary: summaryMatch[1].trim(), startDate: startDate.toISOString() });
            }
        }
    });
    return events.sort((a, b) => new Date(a.startDate).getTime() - new Date(b.startDate).getTime());
};

const formatTime = (seconds) => {
  const isNegative = seconds < 0;
  const absSeconds = Math.abs(Math.round(seconds));
  const h = Math.floor(absSeconds / 3600).toString().padStart(2, '0');
  const m = Math.floor((absSeconds % 3600) / 60).toString().padStart(2, '0');
  const s = (absSeconds % 60).toString().padStart(2, '0');
  return `${isNegative ? '-' : ''}${h}:${m}:${s}`;
};

// --- HOOKS ---
// FIX: Add generic types to the useLocalStorage hook for type safety.
const useLocalStorage = <T,>(key: string, initialValue: T): [T, (value: T | ((val: T) => T)) => void] => {
  const [storedValue, setStoredValue] = useState<T>(() => {
    try {
      const item = window.localStorage.getItem(key);
      return item ? JSON.parse(item) : initialValue;
    } catch (error) { console.error(error); return initialValue; }
  });
  const setValue = (value: T | ((val: T) => T)) => {
    try {
      const valueToStore = value instanceof Function ? value(storedValue) : value;
      setStoredValue(valueToStore);
      window.localStorage.setItem(key, JSON.stringify(valueToStore));
    } catch (error) { console.error(error); }
  };
  return [storedValue, setValue];
};

// FIX: Add types for callback and delay parameters in the useInterval hook.
const useInterval = (callback: () => void, delay: number | null) => {
  const savedCallback = useRef<() => void>();
  useEffect(() => { savedCallback.current = callback; }, [callback]);
  useEffect(() => {
    function tick() { savedCallback.current?.(); }
    if (delay !== null) {
      let id = setInterval(tick, delay);
      return () => clearInterval(id);
    }
  }, [delay]);
};

// --- COMPONENTS ---
// FIX: Add props type to the ApiKeyGate component.
const ApiKeyGate = memo(({ onSelectKey, onSaveKey, isAistudioAvailable }: ApiKeyGateProps) => {
    const [manualApiKey, setManualApiKey] = useState('');

    const handleSave = () => {
        if (manualApiKey.trim()) {
            onSaveKey(manualApiKey.trim());
        }
    };
    
    const handleKeyPress = (e: React.KeyboardEvent) => {
        if (e.key === 'Enter') {
            handleSave();
        }
    };

    return (
        <div className="fixed inset-0 bg-background/80 backdrop-blur-sm flex items-center justify-center z-50 animate-fade-in">
            <div className="bg-surface rounded-xl shadow-lg w-full max-w-sm m-4 p-8 text-center animate-slide-in">
                <h2 className="text-2xl font-bold text-text-primary mb-2">Unlock AI Features</h2>
                {isAistudioAvailable ? (
                    <>
                        <p className="text-text-secondary mb-6">
                            Please select a Gemini API key to enable the AI Chat assistant.
                        </p>
                        <button
                            onClick={onSelectKey}
                            className="w-full p-3 bg-primary text-white font-semibold rounded-md hover:opacity-90 transition-opacity"
                        >
                            Select API Key & Get Started
                        </button>
                    </>
                ) : (
                    <>
                        <p className="text-text-secondary mb-6">
                            Enter your Gemini API key to enable the AI assistant. You can get one from Google AI Studio.
                        </p>
                        <input
                            type="password"
                            value={manualApiKey}
                            onChange={(e) => setManualApiKey(e.target.value)}
                            onKeyPress={handleKeyPress}
                            placeholder="Enter your Gemini API Key"
                            className="w-full p-3 mb-4 text-center rounded-md bg-background border border-surface focus:ring-2 focus:ring-primary outline-none"
                            aria-label="Gemini API Key"
                        />
                        <button
                            onClick={handleSave}
                            disabled={!manualApiKey.trim()}
                            className="w-full p-3 bg-primary text-white font-semibold rounded-md hover:opacity-90 transition-opacity disabled:opacity-50"
                        >
                            Save & Get Started
                        </button>
                    </>
                )}
                <p className="text-xs text-text-secondary mt-4">
                    For more information, see the <a href="https://ai.google.dev/gemini-api/docs/billing" target="_blank" rel="noopener noreferrer" className="underline hover:text-primary">billing documentation</a>.
                </p>
            </div>
        </div>
    );
});

const HeaderClock = () => {
  const [time, setTime] = useState(new Date());
  useEffect(() => {
      const timerId = setInterval(() => setTime(new Date()), 1000);
      return () => clearInterval(timerId);
  }, []);
  return (
      <div className="text-right">
          <div className="font-mono text-base sm:text-lg font-semibold text-text-primary tracking-tight">
              {time.toLocaleTimeString([], { hour: 'numeric', minute: '2-digit', hour12: true })}
          </div>
          <div className="text-[10px] sm:text-xs text-text-secondary">
              {time.toLocaleDateString([], { weekday: 'short', month: 'short', day: 'numeric' })}
          </div>
      </div>
  );
};

// FIX: Add props type to the Header component.
const Header = memo(({ onSettingsClick, onChatClick, hasApiKey }: HeaderProps) => (
    <header className="flex justify-between items-center p-4 md:p-6 animate-fade-in">
      <h1 className="text-2xl font-bold tracking-tighter text-text-primary">GeeClock</h1>
      <div className="flex items-center gap-2 sm:gap-4">
        <HeaderClock />
        <div className="flex items-center gap-2">
          {hasApiKey && <button onClick={onChatClick} className="p-2 rounded-full hover:bg-surface transition-colors" aria-label="Open Chat"><Icon name="chat" className="w-6 h-6" /></button>}
          <button onClick={onSettingsClick} className="p-2 rounded-full hover:bg-surface transition-colors" aria-label="Open Settings"><Icon name="cog" className="w-6 h-6" /></button>
        </div>
      </div>
    </header>
));

const Clock = () => {
  const [time, setTime] = useState(new Date());
  useEffect(() => {
      const timerId = setInterval(() => setTime(new Date()), 1000);
      return () => clearInterval(timerId);
  }, []);
  return (
      <div className="flex flex-col items-center justify-center p-8 animate-fade-in">
          <div className="font-mono text-6xl md:text-8xl lg:text-9xl font-bold tracking-tighter text-primary">
              {time.toLocaleTimeString([], { hour: 'numeric', minute: '2-digit', second: '2-digit', hour12: true })}
          </div>
          <div className="mt-2 text-lg md:text-xl text-text-secondary">
              {time.toLocaleDateString([], { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' })}
          </div>
      </div>
  );
};

// FIX: Add props type to the MusicPlayerCard component.
const MusicPlayerCard = memo(({ timer, onDelete, onUpdate }: MusicPlayerCardProps) => {
  const musicState = timer.musicState || INITIAL_MUSIC_STATE;
  const setMusicState = (newState) => onUpdate(timer.id, { musicState: { ...musicState, ...newState } });
  const getYoutubeEmbedUrl = (url) => {
      let videoId, listId;
      try {
          const urlObj = new URL(url);
          if (url.includes('youtube.com/watch')) { videoId = urlObj.searchParams.get('v'); listId = urlObj.searchParams.get('list'); }
          else if (url.includes('youtu.be/')) { videoId = urlObj.pathname.substring(1); }
          else if (url.includes('youtube.com/playlist')) { listId = urlObj.searchParams.get('list'); }
          if (listId) return `https://www.youtube.com/embed/videoseries?list=${listId}&autoplay=1`;
          if (videoId) return `https://www.youtube.com/embed/${videoId}?autoplay=1`;
      } catch (e) { console.error("Invalid YouTube URL", e); }
      return null;
  };
  const getSpotifyEmbedUrl = (url) => {
      try {
          if (url.includes('open.spotify.com/playlist/')) {
              const playlistId = new URL(url).pathname.split('/').pop();
              return `https://open.spotify.com/embed/playlist/${playlistId}`;
          }
      } catch (e) { console.error("Invalid Spotify URL", e); }
      return null;
  };
  const handleLoad = (type) => {
      if (type === 'youtube') {
          const embedUrl = getYoutubeEmbedUrl(musicState.youtubeInput);
          if (embedUrl) setMusicState({ currentYoutubeUrl: embedUrl });
      } else if (type === 'spotify') {
          const embedUrl = getSpotifyEmbedUrl(musicState.spotifyInput);
          if (embedUrl) setMusicState({ currentSpotifyUrl: embedUrl });
      }
  };
  const activeUrl = musicState.service === 'youtube' ? musicState.currentYoutubeUrl : musicState.currentSpotifyUrl;
  return (
      <div className="bg-surface rounded-xl p-6 flex flex-col gap-4 animate-fade-in shadow-lg transition-all duration-300">
          <div className="flex justify-between items-center">
              <div>
                  <span className="font-bold text-lg text-text-primary">{timer.label}</span>
                  <p className="text-xs text-secondary font-semibold">üéµ Music Mode üéµ</p>
              </div>
              <button onClick={() => onDelete(timer.id)} className="p-2 rounded-full text-text-secondary hover:bg-text-secondary/10 hover:text-red-500 transition-colors" aria-label="Delete timer"><Icon name="trash" className="w-5 h-5" /></button>
          </div>
          <div className="flex items-center justify-center gap-2 p-1 rounded-md bg-background">
              <button onClick={() => setMusicState({ service: 'youtube' })} className={`flex-1 p-1.5 rounded text-sm transition-all ${musicState.service === 'youtube' ? 'bg-surface shadow' : 'opacity-70'}`}>YouTube</button>
              <button onClick={() => setMusicState({ service: 'spotify' })} className={`flex-1 p-1.5 rounded text-sm transition-all ${musicState.service === 'spotify' ? 'bg-surface shadow' : 'opacity-70'}`}>Spotify</button>
          </div>
          <div className="aspect-video w-full">
              <iframe key={activeUrl} className="w-full h-full rounded-lg" src={activeUrl} title={musicState.service === 'youtube' ? "YouTube video player" : "Spotify playlist player"} frameBorder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowFullScreen></iframe>
          </div>
          <div className="pt-4 mt-4 border-t border-white/10 space-y-4">
              <h4 className="text-sm font-semibold text-text-secondary text-center">Use your own playlist</h4>
              <div className="space-y-3">
                  <button onClick={() => setMusicState({ isYoutubeLoggedIn: !musicState.isYoutubeLoggedIn })} disabled={musicState.isYoutubeLoggedIn} className="w-full text-sm p-2 rounded-md bg-[#FF0000]/20 text-white font-semibold disabled:opacity-70 disabled:cursor-not-allowed">{musicState.isYoutubeLoggedIn ? 'Logged In with YouTube ‚úîÔ∏è' : 'Login with YouTube'}</button>
                  {musicState.isYoutubeLoggedIn && (
                      <div className="flex gap-2 animate-fade-in">
                          <input type="text" value={musicState.youtubeInput} onChange={e => setMusicState({ youtubeInput: e.target.value })} placeholder="Paste YouTube URL" className="flex-1 text-sm p-2 rounded-md bg-background border border-surface focus:ring-2 focus:ring-primary outline-none" />
                          <button onClick={() => handleLoad('youtube')} className="px-3 text-sm bg-primary text-white rounded-md">Load</button>
                      </div>
                  )}
              </div>
              <div className="space-y-3">
                  <button onClick={() => setMusicState({ isSpotifyLoggedIn: !musicState.isSpotifyLoggedIn })} disabled={musicState.isSpotifyLoggedIn} className="w-full text-sm p-2 rounded-md bg-[#1DB954]/20 text-white font-semibold disabled:opacity-70 disabled:cursor-not-allowed">{musicState.isSpotifyLoggedIn ? 'Logged In with Spotify ‚úîÔ∏è' : 'Login with Spotify'}</button>
                  {musicState.isSpotifyLoggedIn && (
                      <div className="flex gap-2 animate-fade-in">
                          <input type="text" value={musicState.spotifyInput} onChange={e => setMusicState({ spotifyInput: e.target.value })} placeholder="Paste Spotify Playlist URL" className="flex-1 text-sm p-2 rounded-md bg-background border border-surface focus:ring-2 focus:ring-primary outline-none" />
                          <button onClick={() => handleLoad('spotify')} className="px-3 text-sm bg-primary text-white rounded-md">Load</button>
                      </div>
                  )}
              </div>
          </div>
      </div>
  );
});

// FIX: Add props type to the Timer component.
const Timer = memo(({ timer, onDelete, onToggle, onReset, onUpdate, alarmSoundUrl, compact = false }: TimerProps) => {
    const { remaining } = timer;
    const [isFinished, setIsFinished] = useState(remaining <= 0);
    // FIX: Provide a specific type for the audio ref and initialize it with null.
    const audioRef = useRef<HTMLAudioElement>(null);
    const isMusicPlayer = timer.initialDuration >= 86400;

    useEffect(() => {
      const finished = remaining <= 0;
      if (finished && !isFinished) setIsFinished(true);
      else if (!finished && isFinished) setIsFinished(false);
    }, [remaining, isFinished]);
    
    useEffect(() => {
        if (isFinished && !isMusicPlayer) {
            const sound = audioRef.current;
            if (sound) {
                sound.play().catch(e => console.error("Error playing alarm:", e));
                const timeoutId = setTimeout(() => { if (sound) { sound.pause(); sound.currentTime = 0; }}, 10000);
                return () => clearTimeout(timeoutId);
            }
        }
    }, [isFinished, isMusicPlayer]);

    const handleReset = () => {
        if (audioRef.current) { audioRef.current.pause(); audioRef.current.currentTime = 0; }
        setIsFinished(false);
        onReset(timer.id);
    };
    const handleDelete = () => {
        if (audioRef.current) { audioRef.current.pause(); audioRef.current.currentTime = 0; }
        onDelete(timer.id);
    };
    
    const progress = Math.min(100, ((timer.initialDuration - remaining) / timer.initialDuration) * 100);

    if (isMusicPlayer) {
        return <MusicPlayerCard timer={timer} onDelete={handleDelete} onUpdate={onUpdate} />;
    }
    if (compact) {
        return (
            <div className={`bg-background rounded-lg p-3 flex items-center justify-between gap-3 relative overflow-hidden text-sm flex-shrink-0 w-56 ${isFinished ? 'animate-pulse-red' : ''}`}>
                <button onClick={() => onToggle(timer.id)} className="p-2 bg-primary/20 text-primary rounded-full hover:bg-primary/30 transition-colors" aria-label={timer.isRunning ? 'Pause timer' : 'Start timer'}><Icon name={timer.isRunning ? 'pause' : 'play'} className="w-5 h-5" /></button>
                <div className="flex flex-col overflow-hidden flex-1 text-left">
                    <span className="font-semibold text-text-primary truncate">{timer.label}</span>
                    <span className="font-mono text-lg text-text-primary">{formatTime(remaining)}</span>
                </div>
                <div className="flex flex-col">
                    <button onClick={handleReset} className="p-1 rounded-full text-text-secondary/70 hover:bg-text-secondary/10 transition-colors" aria-label="Reset timer"><Icon name="reset" className="w-4 h-4" /></button>
                    <button onClick={handleDelete} className="p-1 rounded-full text-text-secondary/70 hover:bg-text-secondary/10 hover:text-red-500 transition-colors" aria-label="Delete timer"><Icon name="trash" className="w-4 h-4" /></button>
                </div>
                <audio ref={audioRef} src={alarmSoundUrl} preload="auto" />
            </div>
        );
    }
    return (
      <div className={`bg-surface rounded-xl p-6 flex flex-col justify-between gap-4 relative overflow-hidden animate-fade-in shadow-lg ${isFinished ? 'animate-pulse-red' : ''}`}>
          <div className="absolute bottom-0 left-0 h-1 bg-primary/30" style={{ width: `${progress}%`, transition: 'width 0.25s linear' }} />
          <div className="relative z-10 flex justify-between items-center">
              <span className="font-bold text-lg text-text-primary">{timer.label}</span>
              <button onClick={handleDelete} className="p-2 rounded-full text-text-secondary hover:bg-text-secondary/10 hover:text-red-500 transition-colors" aria-label="Delete timer"><Icon name="trash" className="w-5 h-5" /></button>
          </div>
          <div className="relative z-10 text-center my-4"><span className="font-mono text-5xl sm:text-6xl md:text-7xl font-bold text-primary tracking-tight">{formatTime(remaining)}</span></div>
          <div className="relative z-10 flex justify-center items-center gap-6">
              <button onClick={handleReset} className="p-3 rounded-full text-text-secondary hover:bg-text-secondary/10 transition-colors" aria-label="Reset timer"><Icon name="reset" className="w-6 h-6" /></button>
              <button onClick={() => onToggle(timer.id)} className="w-20 h-20 bg-primary text-white rounded-full flex items-center justify-center shadow-lg hover:opacity-90 transform hover:scale-105 transition-all" aria-label={timer.isRunning ? 'Pause timer' : 'Start timer'}><Icon name={timer.isRunning ? 'pause' : 'play'} className="w-10 h-10" /></button>
              <div className="w-6 h-6 p-3" />
          </div>
          <audio ref={audioRef} src={alarmSoundUrl} preload="auto" />
      </div>
    );
});

// FIX: Add props type to the TimerList component.
const TimerList = memo(({ timers, onAdd, onDelete, onToggle, onReset, onUpdate, alarmSoundUrl }: TimerListProps) => {
    return (
        <div className="p-4 md:p-6 space-y-4 animate-fade-in">
            {timers.length === 0 ? (
                <div className="text-center py-16 text-text-secondary">
                    <p>No timers yet.</p>
                    <button onClick={onAdd} className="mt-4 inline-flex items-center gap-2 px-4 py-2 bg-primary text-white rounded-lg font-semibold hover:opacity-90 transition-opacity">
                        <Icon name="plus" className="w-5 h-5" /> Add Timer
                    </button>
                </div>
            ) : (
                <Fragment>
                    {timers.map(timer => <Timer key={timer.id} timer={timer} onDelete={onDelete} onToggle={onToggle} onReset={onReset} onUpdate={onUpdate} alarmSoundUrl={alarmSoundUrl} />)}
                    <div className="flex justify-center pt-8 pb-4">
                        <button onClick={onAdd} className="inline-flex items-center gap-2 px-6 py-3 bg-primary/10 text-primary rounded-lg font-semibold hover:bg-primary/20 transition-colors">
                            <Icon name="plus" className="w-5 h-5" /> Add Another Timer
                        </button>
                    </div>
                </Fragment>
            )}
        </div>
    );
});

// FIX: Add props type to the Modal component.
const Modal = memo(({ isOpen, onClose, title, children }: ModalProps) => {
  if (!isOpen) return null;
  return (
    <div className="fixed inset-0 bg-background/80 backdrop-blur-sm flex items-center justify-center z-50 animate-fade-in" onClick={onClose} role="dialog" aria-modal="true" aria-labelledby="modal-title">
      <div className="bg-surface rounded-xl shadow-lg w-full max-w-md m-4 animate-slide-in" onClick={e => e.stopPropagation()}>
        <header className="flex justify-between items-center p-4 border-b border-white/10">
          <h2 id="modal-title" className="text-lg font-semibold">{title}</h2>
          <button onClick={onClose} className="p-1 rounded-full hover:bg-white/10" aria-label="Close modal"><Icon name="x" className="w-5 h-5" /></button>
        </header>
        <main>{children}</main>
      </div>
    </div>
  );
});

// FIX: Add props type to the AddTimerModal component.
const AddTimerModal = memo(({ isOpen, onClose, onAddTimer }: AddTimerModalProps) => {
    const [label, setLabel] = useLocalStorage<string>('addTimer-label', '');
    const [hours, setHours] = useLocalStorage<number>('addTimer-hours', 0);
    const [minutes, setMinutes] = useLocalStorage<number>('addTimer-minutes', 0);
    const [seconds, setSeconds] = useLocalStorage<number>('addTimer-seconds', 0);
    const handleSubmit = (e: React.FormEvent) => {
        e.preventDefault();
        const duration = (Number(hours) * 3600) + (Number(minutes) * 60) + Number(seconds);
        if (duration > 0) {
            onAddTimer({ label: label || 'New Timer', duration });
            setLabel(''); setHours(0); setMinutes(0); setSeconds(0);
            onClose();
        }
    };
    return (
        <Modal isOpen={isOpen} onClose={onClose} title="Add New Timer">
            <form onSubmit={handleSubmit} className="space-y-4 p-4">
                <div>
                    <label htmlFor="label" className="block text-sm font-medium text-text-secondary">Label</label>
                    <input type="text" id="label" value={label} onChange={e => setLabel(e.target.value)} placeholder="e.g., Cooking Pasta" className="mt-1 w-full p-2 rounded-md bg-background border border-surface focus:ring-2 focus:ring-primary outline-none" />
                </div>
                <div className="flex gap-2">
                    <div className="flex-1">
                        <label htmlFor="hours" className="block text-sm font-medium text-text-secondary">Hours</label>
                        <input type="number" id="hours" value={hours} onChange={e => setHours(parseInt(e.target.value, 10) || 0)} onFocus={e => e.target.select()} min="0" className="mt-1 w-full p-2 rounded-md bg-background border border-surface focus:ring-2 focus:ring-primary outline-none" />
                    </div>
                    <div className="flex-1">
                        <label htmlFor="minutes" className="block text-sm font-medium text-text-secondary">Minutes</label>
                        <input type="number" id="minutes" value={minutes} onChange={e => setMinutes(parseInt(e.target.value, 10) || 0)} onFocus={e => e.target.select()} min="0" max="59" className="mt-1 w-full p-2 rounded-md bg-background border border-surface focus:ring-2 focus:ring-primary outline-none" />
                    </div>
                    <div className="flex-1">
                        <label htmlFor="seconds" className="block text-sm font-medium text-text-secondary">Seconds</label>
                        <input type="number" id="seconds" value={seconds} onChange={e => setSeconds(parseInt(e.target.value, 10) || 0)} onFocus={e => e.target.select()} min="0" max="59" className="mt-1 w-full p-2 rounded-md bg-background border border-surface focus:ring-2 focus:ring-primary outline-none" />
                    </div>
                </div>
                <button type="submit" className="w-full p-2 bg-primary text-white font-semibold rounded-md hover:opacity-90 transition-opacity">Add Timer</button>
            </form>
        </Modal>
    );
});

// FIX: Add props type to the SettingsModal component.
const SettingsModal = memo(({ isOpen, onClose, settings, onSettingsChange }: SettingsModalProps) => {
    const [icalUrl, setIcalUrl] = useState(settings.iCalUrl || '');
    // FIX: Provide a specific type for the audio ref and initialize it with null.
    const audioRef = useRef<HTMLAudioElement>(null);
    const handleSave = () => { onSettingsChange({ ...settings, iCalUrl: icalUrl }); onClose(); };
    const testSound = () => { if (audioRef.current) audioRef.current.play().catch(e => alert("Audio playback failed. Please interact with the page first.")); };
    const alarmSoundUrl = ALARM_SOUNDS[settings.alarmSound]?.url || ALARM_SOUNDS.default.url;
    return (
        <Modal isOpen={isOpen} onClose={handleSave} title="Settings">
            <div className="p-4 space-y-6">
                <div className="space-y-2">
                    <label className="block text-sm font-medium text-text-secondary">Theme</label>
                    <div className="grid grid-cols-3 gap-2">
                        {Object.keys(themes).map(themeKey => <button key={themeKey} onClick={() => onSettingsChange({ ...settings, theme: themeKey })} className={`p-2 rounded-md text-sm capitalize transition-all ${settings.theme === themeKey ? 'ring-2 ring-primary font-semibold' : 'bg-background hover:bg-background/80'}`}>{themeKey}</button>)}
                    </div>
                </div>
                <div className="flex justify-between items-center">
                    <label className="block text-sm font-medium text-text-secondary">Dark Mode</label>
                    <button onClick={() => onSettingsChange({ ...settings, darkMode: !settings.darkMode })} className={`relative inline-flex items-center h-6 rounded-full w-11 transition-colors ${settings.darkMode ? 'bg-primary' : 'bg-gray-400'}`}><span className={`inline-block w-4 h-4 transform bg-white rounded-full transition-transform ${settings.darkMode ? 'translate-x-6' : 'translate-x-1'}`} /></button>
                </div>
                <div className="space-y-2">
                  <label htmlFor="alarm-sound" className="block text-sm font-medium text-text-secondary">Alarm Sound</label>
                  <div className="flex gap-2 items-center">
                      <select id="alarm-sound" value={settings.alarmSound} onChange={e => onSettingsChange({ ...settings, alarmSound: e.target.value })} className="flex-1 mt-1 w-full p-2 rounded-md bg-background border border-surface focus:ring-2 focus:ring-primary outline-none">{Object.entries(ALARM_SOUNDS).map(([key, { name }]) => <option key={key} value={key}>{name}</option>)}</select>
                      <button onClick={testSound} className="p-2 mt-1 rounded-md bg-secondary text-white">Test</button>
                      <audio ref={audioRef} src={alarmSoundUrl} preload="auto" />
                  </div>
                </div>
                <div className="space-y-2">
                  <label htmlFor="ical-url" className="block text-sm font-medium text-text-secondary">iCal Calendar URL</label>
                  <input type="text" id="ical-url" value={icalUrl} onChange={e => setIcalUrl(e.target.value)} placeholder="Paste your iCal link here" className="mt-1 w-full p-2 rounded-md bg-background border border-surface focus:ring-2 focus:ring-primary outline-none" />
                  <p className="text-xs text-text-secondary">Sync your calendar for 5-minute pre-event timers.</p>
                </div>
                <button onClick={handleSave} className="w-full p-2 bg-primary text-white font-semibold rounded-md hover:opacity-90 transition-opacity">Save & Close</button>
            </div>
        </Modal>
    );
});

// FIX: Add props type to the ChatBot component.
const ChatBot = memo(({ isOpen, onClose, timers, onDeleteTimer, onToggleTimer, onResetTimer, alarmSoundUrl, onUpdateTimer, onApiKeyInvalid, apiKey }: ChatBotProps) => {
    const [messages, setMessages] = useLocalStorage<Message[]>('chat-messages', []);
    const [input, setInput] = useLocalStorage<string>('chat-input', '');
    const [isLoading, setIsLoading] = useState(false);
    const messagesEndRef = useRef<HTMLDivElement>(null);
    
    useEffect(() => { messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' }); }, [messages]);
    
    const handleSend = async () => {
        if (!input.trim() || isLoading) return;
        if (!apiKey) {
            setMessages(prev => [...prev, { role: 'model', text: 'API Key is not configured. Please set it to use the AI assistant.'}]);
            return;
        }
        const userMessage: Message = { role: 'user', text: input };
        const newMessages = [...messages, userMessage];
        setMessages(newMessages); setInput(''); setIsLoading(true);
        try {
            const ai = new GoogleGenAI({ apiKey });
            const history = newMessages.map(msg => ({
                role: msg.role,
                parts: [{ text: msg.text }]
            }));
            const response: GenerateContentResponse = await ai.models.generateContent({ model: 'gemini-2.5-flash', contents: history });
            // FIX: Access the response text directly via the `text` property as per the SDK guidelines.
            // Using `|| ''` to ensure a string is always passed, satisfying the type checker if `response.text` is inferred as potentially non-string.
            setMessages([...newMessages, { role: 'model', text: response.text || '' }]);
        } catch (error) { 
            console.error(error); 
            if (error instanceof Error && (error.message.includes("API key not valid") || error.message.includes("Requested entity was not found."))) {
                onApiKeyInvalid();
                setMessages([...newMessages, { role: 'model', text: 'Your API Key seems to be invalid. Please select a new one or update your existing key to continue.' }]);
            } else {
                setMessages([...newMessages, { role: 'model', text: 'Sorry, an error occurred.' }]);
            }
        }
        finally { setIsLoading(false); }
    };
    return (
        <Modal isOpen={isOpen} onClose={onClose} title="GeeClock AI">
            <div className="flex flex-col h-[70vh]">
                {timers.length > 0 && (
                  <div className="p-3 border-b border-white/10"><div className="flex gap-3 overflow-x-auto pb-2">{timers.map(timer => <Timer key={timer.id} timer={timer} onDelete={onDeleteTimer} onToggle={onToggleTimer} onReset={onResetTimer} onUpdate={onUpdateTimer} alarmSoundUrl={alarmSoundUrl} compact={true} />)}</div></div>
                )}
                <div className="flex-1 p-4 overflow-y-auto space-y-4">
                    {messages.map((msg, index) => <div key={index} className={`flex ${msg.role === 'user' ? 'justify-end' : 'justify-start'}`}><div className={`max-w-xs md:max-w-md lg:max-w-lg px-4 py-2 rounded-xl ${msg.role === 'user' ? 'bg-primary text-white' : 'bg-background'}`}><p style={{ whiteSpace: 'pre-wrap' }}>{msg.text}</p></div></div>)}
                    {isLoading && <div className="flex justify-start"><div className="max-w-xs md:max-w-md lg:max-w-lg px-4 py-2 rounded-xl bg-background"><div className="flex items-center space-x-2"><div className="w-2 h-2 bg-text-secondary rounded-full animate-pulse"></div><div className="w-2 h-2 bg-text-secondary rounded-full animate-pulse" style={{ animationDelay: '0.2s' }}></div><div className="w-2 h-2 bg-text-secondary rounded-full animate-pulse" style={{ animationDelay: '0.4s' }}></div></div></div></div>}
                    <div ref={messagesEndRef} />
                </div>
                <div className="p-4 border-t border-white/10">
                    <div className="flex items-center gap-2">
                        <input type="text" value={input} onChange={(e) => setInput(e.target.value)} onKeyPress={(e) => e.key === 'Enter' && handleSend()} placeholder="Ask me anything..." className="flex-1 p-2 rounded-md bg-background border border-surface focus:ring-2 focus:ring-primary outline-none" disabled={isLoading} />
                        <button onClick={handleSend} disabled={isLoading || !input.trim()} className="p-2 bg-primary text-white rounded-md disabled:opacity-50">{isLoading ? '...' : <Icon name="send" className="w-5 h-5" />}</button>
                    </div>
                </div>
            </div>
        </Modal>
    );
});

// FIX: Add props type to the NavButton component.
const NavButton = memo(({ tabName, icon, children, activeTab, onTabClick }: NavButtonProps) => (
    <button onClick={() => onTabClick(tabName)} className={`flex-1 p-3 text-sm font-semibold flex items-center justify-center gap-2 transition-all rounded-t-lg ${activeTab === tabName ? 'bg-surface text-primary' : 'text-text-secondary hover:bg-surface/50'}`}><Icon name={icon} className="w-5 h-5" />{children}</button>
));

const App = () => {
  const [settings, setSettings] = useLocalStorage<Settings>('settings', INITIAL_SETTINGS);
  const [timers, setTimers] = useLocalStorage<TimerData[]>('timers', []);
  const [activeTab, setActiveTab] = useLocalStorage<string>('activeTab', 'clock');
  const [isAddModalOpen, setAddModalOpen] = useState(false);
  const [isSettingsModalOpen, setSettingsModalOpen] = useState(false);
  const [isChatModalOpen, setChatModalOpen] = useState(false);
  const [localApiKey, setLocalApiKey] = useLocalStorage<string>('gemini-api-key', '');
  const [apiKeyStatus, setApiKeyStatus] = useState('checking'); // 'checking', 'aistudio_found', 'manual_found', 'not_found'
  const [isAistudioAvailable, setIsAistudioAvailable] = useState(false);

  useEffect(() => {
      const root = document.documentElement;
      const theme = themes[settings.theme] || themes.default;
      const colors = settings.darkMode ? theme.dark : theme.light;
      for (const [key, value] of Object.entries(colors)) { root.style.setProperty(`--color-${key}`, value); }
      document.body.classList.toggle('dark', settings.darkMode);
  }, [settings.theme, settings.darkMode]);
  
  const checkApiKey = useCallback(async () => {
    // FIX: Ensure window.aistudio exists before accessing its properties.
    if (typeof (window as any).aistudio?.hasSelectedApiKey === 'function') {
        setIsAistudioAvailable(true);
        try {
            if (await (window as any).aistudio.hasSelectedApiKey()) {
                setApiKeyStatus('aistudio_found');
            } else {
                setApiKeyStatus('not_found');
            }
        } catch (e) {
            console.error("Error checking for API key:", e);
            setApiKeyStatus('not_found');
        }
    } else {
        setIsAistudioAvailable(false);
        if (localApiKey) {
            setApiKeyStatus('manual_found');
        } else {
            setApiKeyStatus('not_found');
        }
    }
  }, [localApiKey]);

  useEffect(() => {
      checkApiKey();
  }, [checkApiKey]);

  const handleSelectKey = useCallback(async () => {
    if (typeof (window as any).aistudio?.openSelectKey !== 'function') {
        alert("API key selection is not available in this environment.");
        return;
    }
    try {
        await (window as any).aistudio.openSelectKey();
        setApiKeyStatus('aistudio_found');
    } catch (e) {
        console.error("Failed to open API key selection:", e);
    }
  }, []);

  const handleSaveKey = useCallback((key: string) => {
    setLocalApiKey(key);
    setApiKeyStatus('manual_found');
  }, [setLocalApiKey]);

  const handleApiKeyInvalid = useCallback(() => {
      if (isAistudioAvailable) {
          setApiKeyStatus('not_found');
      } else {
          setLocalApiKey('');
          setApiKeyStatus('not_found');
      }
  }, [isAistudioAvailable, setLocalApiKey]);
  
  const addTimer = useCallback((timerData: {label: string, duration: number}, startImmediately = false) => {
      const initialDuration = timerData.duration;
      const newTimer: TimerData = {
          id: Date.now(),
          label: timerData.label,
          initialDuration: initialDuration,
          duration: initialDuration,
          remaining: initialDuration,
          isRunning: startImmediately,
          startTime: startImmediately ? Date.now() : null,
          musicState: initialDuration >= 86400 ? { ...INITIAL_MUSIC_STATE } : null,
      };
      setTimers(prev => [...prev, newTimer]);
  }, [setTimers]);

  useEffect(() => {
      if (!settings.iCalUrl) return;
      const fetchCalendar = async () => {
          try {
              const response = await fetch(`https://api.allorigins.win/raw?url=${encodeURIComponent(settings.iCalUrl)}`);
              if (!response.ok) throw new Error('Network error');
              const events = parseICal(await response.text());
              if (events.length > 0) {
                  const nextEvent = events[0];
                  const notifyTime = new Date(new Date(nextEvent.startDate).getTime() - 5 * 60 * 1000);
                  if (notifyTime > new Date() && !timers.some(t => t.label === `Event: ${nextEvent.summary}`)) {
                       addTimer({ label: `Event: ${nextEvent.summary}`, duration: Math.round((notifyTime.getTime() - new Date().getTime()) / 1000) }, true);
                  }
              }
          } catch (error) { console.error('iCal fetch error:', error); }
      };
      fetchCalendar();
      const intervalId = setInterval(fetchCalendar, 3600000);
      return () => clearInterval(intervalId);
  }, [settings.iCalUrl, timers, addTimer]);
  
  useInterval(() => {
    setTimers(prev => prev.map(t => {
      if (!t.isRunning || !t.startTime) return t;
      const elapsed = (Date.now() - Number(t.startTime)) / 1000;
      return { ...t, remaining: Number(t.duration) - elapsed };
    }));
  }, 250);
  
  const deleteTimer = useCallback((id: number) => setTimers(prev => prev.filter(t => t.id !== id)), [setTimers]);
  const toggleTimer = useCallback((id: number) => {
      setTimers(prev => prev.map(t => {
          if (t.id !== id) return t;
          if (t.isRunning) { // PAUSE
              const elapsed = (Date.now() - (t.startTime ?? 0)) / 1000;
              return { ...t, isRunning: false, duration: t.duration - elapsed, startTime: null };
          } else { // PLAY
              return { ...t, isRunning: true, startTime: Date.now() };
          }
      }));
  }, [setTimers]);
  const resetTimer = useCallback((id: number) => setTimers(prev => prev.map(t => t.id === id ? {...t, isRunning: false, remaining: t.initialDuration, duration: t.initialDuration, startTime: null} : t )), [setTimers]);
  const updateTimer = useCallback((id: number, updates: Partial<TimerData>) => setTimers(prev => prev.map(t => t.id === id ? { ...t, ...updates } : t)), [setTimers]);
  
  const openSettingsModal = useCallback(() => setSettingsModalOpen(true), []);
  const closeSettingsModal = useCallback(() => setSettingsModalOpen(false), []);
  const openChatModal = useCallback(() => setChatModalOpen(true), []);
  const closeChatModal = useCallback(() => setChatModalOpen(false), []);
  const openAddModal = useCallback(() => setAddModalOpen(true), []);
  const closeAddModal = useCallback(() => setAddModalOpen(false), []);
  
  const alarmSoundUrl = ALARM_SOUNDS[settings.alarmSound]?.url || ALARM_SOUNDS.default.url;
  const hasApiKey = apiKeyStatus === 'aistudio_found' || apiKeyStatus === 'manual_found';
  const effectiveApiKey = apiKeyStatus === 'aistudio_found' ? process.env.API_KEY : localApiKey;

  return (
      <div className="flex flex-col h-screen max-h-screen bg-background">
          {apiKeyStatus === 'not_found' && <ApiKeyGate onSelectKey={handleSelectKey} onSaveKey={handleSaveKey} isAistudioAvailable={isAistudioAvailable} />}
          <Header onSettingsClick={openSettingsModal} onChatClick={openChatModal} hasApiKey={hasApiKey} />
          <main className="flex-1 flex flex-col overflow-y-auto">
              <nav className="flex px-4 md:px-6 border-b border-surface">
                  <NavButton tabName="clock" icon="clock" activeTab={activeTab} onTabClick={setActiveTab}>Clock</NavButton>
                  <NavButton tabName="timers" icon="timer" activeTab={activeTab} onTabClick={setActiveTab}>Timers</NavButton>
              </nav>
              <div className="flex-1">{activeTab === 'clock' ? <Clock /> : <TimerList timers={timers} onAdd={openAddModal} onDelete={deleteTimer} onToggle={toggleTimer} onReset={resetTimer} onUpdate={updateTimer} alarmSoundUrl={alarmSoundUrl} />}</div>
          </main>
          <AddTimerModal isOpen={isAddModalOpen} onClose={closeAddModal} onAddTimer={addTimer} />
          <SettingsModal isOpen={isSettingsModalOpen} onClose={closeSettingsModal} settings={settings} onSettingsChange={setSettings} />
           <ChatBot isOpen={isChatModalOpen} onClose={closeChatModal} timers={timers} onDeleteTimer={deleteTimer} onToggleTimer={toggleTimer} onResetTimer={resetTimer} onUpdateTimer={updateTimer} alarmSoundUrl={alarmSoundUrl} onApiKeyInvalid={handleApiKeyInvalid} apiKey={effectiveApiKey} />
      </div>
  );
};

const container = document.getElementById('root');
// FIX: Ensure container is not null before creating a root.
if (container) {
    const root = ReactDOM.createRoot(container);
    root.render(<App />);
}
